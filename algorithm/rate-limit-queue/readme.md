# Golang限速算法和应用
问题：假设完全不懂算法，如何实现一个限速功能（1秒内最多100次）

## 1. 计数器法
该算法需要两个属性 startTime， count

if 当前时间 - startTime > 1, 重制startTime and count

if count > limitNum , wait....

## 2. 滑动窗口计数法
这个算法实际上是前面这种算法的改进版，第一种方法的问题在于统计的时间太粗了，不够精细，假设我们把1s细分为1000ms，那么也就是10ms一个请求，
这时候我们只需要统计最近100个10ms段内的请求数就可以了，而不是一个固定的开始时间。
这个算法有一个非常知名的应用就是在TCP网络中流量控制中用于计算窗口大小

## 3. 漏桶算法
所谓漏桶算法就是有一个固定大小的桶，进水速率不确定，但是出水速率固定，这里所谓的进水指的就是请求，而出水则是处理请求。

漏桶算法有以下特点：
- 漏桶具有固定容量，出水速率是固定常量（流出请求）
- 如果桶是空的，则不需流出水滴
- 可以以任意速率流入水滴到漏桶（流入请求）
- 如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）
漏桶算法实现的重点在于有一个桶的容量、速率、当前水量、一个动态的时间戳，我们通过每次计算当前时间和上次时间的间隔*速率得到一个漏去的水量，
把当前水量减去这个值就是当前剩余水量。

## 4. 令牌桶算法
令牌桶算法和漏桶算法的方向刚好是相反的，我们有一个固定的桶，桶里存放着令牌（token）。一开始桶是空的，系统按固定的时间（rate）往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。

## 5 .Go WaitGroup 限速
在Go里面我们还可以使用chanel结合生产者消费者模式轻松实现

## 6. Go“标准库”的限速包
在日常开发中，很多时候我们对限速要求并不是十分精准，比如说我们要用协程并发调一个接口100次，一个接口耗时3s，但是这个接口的并发能力不强，如果不做限制很可能把接口打垮，
假设要求qps低于10，也就说最多每秒10个请求，利用Go的协程可以轻松实现。

[Golang限速算法和应用](https://wangbjun.site/2020/coding/golang/limiter.html)
